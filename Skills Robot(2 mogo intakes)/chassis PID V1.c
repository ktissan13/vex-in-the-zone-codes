#pragma config(Sensor, in1,    gyro,           sensorGyro)
#pragma config(Sensor, in2,    F_pot,          sensorPotentiometer)
#pragma config(Sensor, in3,    B_pot,          sensorPotentiometer)
#pragma config(Sensor, dgtl3,  rightDrive_enc, sensorQuadEncoder)
#pragma config(Sensor, dgtl1,  leftDrive_enc,  sensorQuadEncoder)
#pragma config(Motor,  port8,           F_mogo_r,      tmotorVex393HighSpeed_HBridge, openLoop)
#pragma config(Motor,  port10,           right_1,       tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port1,           left_1,        tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           right_2,       tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           F_mogo_l,      tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           B_mogo_r,      tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           left_2,        tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port2,           right_3,       tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           left_3,        tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port7,          B_mogo_l,      tmotorVex393HighSpeed_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/***************************
Nana Abekah
Team 356B
Start of project: 12/13/2017
***************************/

/*This directory contains all functions used during autonomous, driver control and skills*/

#include "library/pid_h.h"
#include "library/simplifications and variables.h"


int gyroTolerance = 5;

//function for the right chassis
void right_chassis(int speed){
	motor[right_1] = -speed;
	motor[right_2] = speed;
	motor[right_3] = -speed;
}
//function for the left chassis
void left_chassis(int speed){
	motor[left_1] = speed;
	motor[left_2] = speed;
	motor[left_3] = -speed;
}
//function to drive both chassis
void drive_chassis(int speed){
	left_chassis(speed);
	right_chassis(speed);
}
/*useless for autonomous routines
only used for drive control
This function is for front mobile goal*/
void F_mogo(int speed){
	motor[F_mogo_l] = -speed;
	motor[F_mogo_r] = speed;
}
/*useless for autonomous routines
only used for drive control
This function is for back mobile goal*/
void B_mogo(int speed){
	motor[B_mogo_l] = -speed;
	motor[B_mogo_r] = speed;
}
//function to reset chassis encoder values
void drive_chassis_init(){
	rightD_enc = 0;
	leftD_enc = 0;
	wait1Msec(250);
}
//function to calibrate gyro
void dgyro_chassis_init(){
	D_gyro = sensorNone;
	wait1Msec(200);
	D_gyro = sensorGyro;
	wait1Msec(100);
}


pid drivebase; //drivebase PID class
pid drivegyro; //gyro PID class

//drivebase PID constants
void drivebase_PID_init(){
	drivebase.kP = 0.89; //0.78 .199
	drivebase.kI = 0.0009;  //0.0009 .0051
	drivebase.kD = 2.2;  //2.2  1.25
}
//gyro PID constants
void drivegyro_PID_init(){
	drivegyro.kP = 0.2;
	drivegyro.kI = 0.009;
	drivegyro.kD = 1.5;
}
//function for front mobile goal used in autonomous routines
void frontMogo(int speed){
	motor[F_mogo_l] = speed;
	motor[F_mogo_r] = -speed;
}
//function for back mobile goal used in autonomous routines
void backMogo(int speed){
	motor[B_mogo_l] = -speed;
	motor[B_mogo_r] = speed;
}

//function to control front mobile goal with potentiometer
void frontMogo_potControl(int speed, int state){ //// State = 0 for up; State = 1 for down.
	int up = 1255; //potentiometer value when the subsystem is up
	int down = 3060; //potentiometer value when the subsystem is down
	//Bring the front mobile goal up if it is not
	if(state == 0 && front_pot > up){
		while(front_pot > up){	frontMogo(speed);	}
		frontMogo(0);
		wait1Msec(250);
		}else if(state == 1 && front_pot < down){ //Bring the down mobile goal up if it is not
		while(front_pot < down){	frontMogo(-speed);	}
		frontMogo(0);
		wait1Msec(250);
		}else{ //
		frontMogo(0);
		wait10Msec(25);
	}
}
//function to control back mobile goal with potentiometer
void backMogo_potControl(int speed, int state){ //// State = 0 for up; State = 1 for down.
	int up = 1050;
	int down = 200;
	if(state == 0 && back_pot < up){
		while(back_pot < up){	backMogo(speed);	}
		backMogo(0);
		wait1Msec(250);
		}else if(state == 1 && back_pot > down){
		while(back_pot > down){	backMogo(-speed);	}
		backMogo(0);
		wait1Msec(250);
		}else{
		backMogo(0);
		wait10Msec(25);
	}
}

void _bMogo(int speed){
	motor[B_mogo_l] = -speed;
	motor[B_mogo_r] = speed;
	wait1Msec(900);
	motor[B_mogo_l] = 0;
	motor[B_mogo_r] = 0;
}

void _fMogo(int speed){
	motor[F_mogo_l] = speed;
	motor[F_mogo_r] = -speed;
	wait1Msec(700);
	motor[F_mogo_l] = 0;
	motor[F_mogo_r] = 0;
}

void drive_correction(int speed){
	bool forward = true;
	if(rightD_enc < 0 && leftD_enc < 0)
		forward = false;

	if(forward){
		if(rightD_enc > leftD_enc){
			right_chassis(speed - 5);
			left_chassis(speed);
			}else if(leftD_enc > rightD_enc){
			right_chassis(speed);
			left_chassis(speed - 5);
			}else{
			drive_chassis(speed);
		}
		}else{
		if(rightD_enc < leftD_enc){
			right_chassis(speed + 5);
			left_chassis(speed);
			}else if(leftD_enc < rightD_enc){
			right_chassis(speed);
			left_chassis(speed + 5);
			}else{
			drive_chassis(speed);
		}
	}
}

//simple PID control for the chassis encoders for better precision
void drivebase_PID(int distance) {
	drivebase_PID_init();
	drivebase.target = distance;
	drivebase.error = drivebase.target - leftD_enc;
	if(drivebase.error > 0){
		while(drivebase.error > 0){
			drivebase.error = drivebase.target - leftD_enc;

			if(abs(drivebase.error) < 50)
				drivebase.integral += drivebase.error;
			else
				drivebase.integral = 0;



			//if(abs(drivebase.error) < 10) {	drivebase.error = 0;	}

			drivebase.derivative = drivebase.error - drivebase.last_error;
			drivebase.last_error = drivebase.error;

			if(drivebase.error == 0) { drivebase.integral = 0; drivebase.derivative = 0;}

			int speed = ((drivebase.kP*drivebase.error)+(drivebase.integral*drivebase.kI)+(drivebase.derivative*drivebase.kD));

			drive_correction(speed);
			delay(25);
		}
		}else{
		while(drivebase.error < 0){
			drivebase.error = drivebase.target - leftD_enc;

			/*if(abs(drivebase.error)<250)
			drivebase.integral += drivebase.error;
			else
			drivebase.integral = 0;*/

			if(abs(drivebase.error) < 100)
				drivebase.integral += drivebase.error;
			else
				drivebase.integral = 0;



			//if(abs(drivebase.error) < 10) {	drivebase.error = 0;	}

			drivebase.derivative = drivebase.error - drivebase.last_error;
			drivebase.last_error = drivebase.error;

			if(drivebase.error == 0) { drivebase.integral = 0; drivebase.derivative = 0;}

			int speed = ((drivebase.kP*drivebase.error)+(drivebase.integral*drivebase.kI)+(drivebase.derivative*drivebase.kD));

			drive_correction(speed);
			//drive_chassis(speed);
			delay(25);
		}
	}
}

//not using this function at the moment. It is too slow and requires more tuning.
void drivegyro_PID(int angle){
	drivegyro.target = angle;
	drivegyro_PID_init();
	drivegyro.error = drivegyro.target - abs(D_gyro);
	while(drivegyro.error > 0){
		drivegyro.error = drivegyro.target - abs(D_gyro);

		if(abs(drivegyro.error) < 200)
			drivegyro.integral += drivegyro.error;
		else
			drivegyro.integral = 0;

		if(drivegyro.error == 0) {	drivegyro.integral = 0;	}

		drivegyro.derivative = drivegyro.error - drivegyro.last_error;
		drivegyro.last_error = drivegyro.error;

		int turn_speed = (drivegyro.kP*drivegyro.error)+(drivegyro.integral*drivegyro.kI)+(drivegyro.derivative*drivegyro.kD);
		right_chassis(turn_speed);
		left_chassis(-turn_speed);
		delay(25);
	}
}

void _drivegyro(int angle, int speed){
	if((D_gyro) < angle - 100){
		int gyroError = abs(angle)-abs(D_gyro);
		while((D_gyro) < angle - 100){
			//...Continue turning
			right_chassis(speed);
			left_chassis(-speed);
			gyroError = abs(angle)-abs(D_gyro);
		}
		//Brief brake to eliminate some drift
		right_chassis(-25);
		left_chassis(25);
		wait1Msec(100);
		//Second while loop to move more slowly toward the goal
		while((D_gyro) != angle && abs(gyroError) > gyroTolerance){
			if((D_gyro) > angle){
				right_chassis(-40);
				left_chassis(40);
				}else{
				right_chassis(40);
				left_chassis(-40);
			}
			gyroError = abs(angle)-abs(D_gyro);
		}
		//Stop
		right_chassis(0);
		left_chassis(0);
		wait1Msec(100);
		}else{
		int gyroError = abs(angle)-abs(D_gyro);
		while((D_gyro) > angle - 100){
			//...Continue turning
			right_chassis(-speed);
			left_chassis(speed);
			gyroError = abs(angle)-abs(D_gyro);
		}
		//Brief brake to eliminate some drift
		right_chassis(25);
		left_chassis(-25);
		wait1Msec(100);
		//Second while loop to move more slowly toward the goal
		while((D_gyro) != angle && abs(gyroError) > gyroTolerance){
			if((D_gyro) < angle){
				right_chassis(40);
				left_chassis(-40);
				}else{
				right_chassis(-40);
				left_chassis(40);
			}
			gyroError = abs(angle)-abs(D_gyro);
		}
		//Stop
		right_chassis(0);
		left_chassis(0);
		wait1Msec(100);
	}
}

void roll_chassis(){
	drive_chassis(20);
	wait1Msec(500);
	drive_chassis(0);
}

void _driveForward(int distance, int speed){
	int D_error = distance - leftD_enc;
	while(D_error > 0){
		drive_chassis(speed);
		D_error = distance - leftD_enc;
	}
	while(D_error < 0){	drive_chassis(-50);	D_error = distance - leftD_enc;}
	drive_chassis(0);
	wait1Msec(100);
}

void _driveBack(int distance, int speed){
	int D_error = distance - leftD_enc;
	while(D_error < 0){
		drive_chassis(speed);
		D_error = distance - leftD_enc;
	}
	while(D_error > 0){	drive_chassis(-50);	D_error = distance - leftD_enc;}
	drive_chassis(0);
	wait1Msec(100);
}
