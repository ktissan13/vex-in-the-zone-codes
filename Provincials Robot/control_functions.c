#pragma config(Sensor, in8,    gyro,           sensorGyro)
#pragma config(Sensor, dgtl9,  RIGHT_DRIVE_ENC, sensorQuadEncoder)
#pragma config(Sensor, dgtl11,  LEFT_DRIVE_ENC, sensorQuadEncoder)
#pragma config(Sensor, dgtl7,  LIFT,           sensorQuadEncoder)
#pragma config(Motor,  port1,           MOBILE_GOAL_INTAKE, tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port9,           Chainbar,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           RIGHT_DRIVE_F, tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           RIGHT_DRIVE_B, tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           RIGHT_LIFT_BOTTOM,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           LEFT_LIFT_BOTTOM,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           LEFT_DRIVE_B,  tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           LEFT_DRIVE_F,  tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port2,           Lift,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          ROLLERS,       tmotorVex393HighSpeed_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "Subsystems/simpleSensors.h"

void _chainbar(int speed){
	//motor[RIGHT_C_BAR] = speed;
	//motor[LEFT_C_B] = speed;
	motor[Chainbar] = speed;
}

void drive(int leftDrive, int rightDrive){
	motor[RIGHT_DRIVE_B] = rightDrive;
		motor[RIGHT_DRIVE_F] = rightDrive;
		motor[LEFT_DRIVE_B] = leftDrive;
		motor[LEFT_DRIVE_F] = leftDrive;
}

void _chassis(int leftDrive, int rightDrive){
	if(vexRT[Btn6U] == true){
		motor[RIGHT_DRIVE_B] = -rightDrive;
		motor[RIGHT_DRIVE_F] = -rightDrive;
		motor[LEFT_DRIVE_B] = -leftDrive;
		motor[LEFT_DRIVE_F] = -leftDrive;
	}else{
		motor[RIGHT_DRIVE_B] = rightDrive;
		motor[RIGHT_DRIVE_F] = rightDrive;
		motor[LEFT_DRIVE_B] = leftDrive;
		motor[LEFT_DRIVE_F] = leftDrive;
	}
}
void _mobileGoal(int speed){
	motor[MOBILE_GOAL_INTAKE] = speed;
}

void _lift(int speed){
	motor[RIGHT_LIFT_BOTTOM] = -speed;
	motor[LEFT_LIFT_BOTTOM] = -speed;
	motor[Lift] = speed;
}

void _intake(int speed){
	motor[ROLLERS] = speed;
}
void Drive_enc(int distance, int speed){
	speed*=-1;
	if(LD_ENC <= distance){
		while(LD_ENC <= distance){
			_chassis(speed, speed);
		}
		_chassis(-75, -75);
		wait1Msec(100);
		_chassis(0, 0);
	}else{
		while(LD_ENC >= distance){
			_chassis(-speed, -speed);
		}
		_chassis(75, 75);
		wait1Msec(100);
		_chassis(0, 0);
	}
}

void Lift_encoder(int height, int speed){
	if(LIFT_ENC <= height){
		while(LIFT_ENC <= height){
			_lift(speed);
		}
		_lift(-25);
		wait1Msec(100);
		_lift(15);
	}else{
		while(LIFT_ENC >= height){
			_lift(-speed);
		}
	}
	_lift(15);
}

void gyro_init(){
	D_gyro = sensorNone;
  wait1Msec(200);
  D_gyro = sensorGyro;
  wait1Msec(100);
}

void chassis_init(){
	RD_ENC = 0;
	LD_ENC = 0;
	wait1Msec(200);
}


void _drivegyro(int angle, int speed){
	speed*=-1;
  while((D_gyro) < angle - 100){
		drive(-speed, speed);

  }
  //Brief brake to eliminate some drift
	drive(45, -45);
  wait1Msec(100);
  /*Second while loop to move more slowly toward the goal
  while((D_gyro) != angle){
    if((D_gyro) > angle){
			_chassis(40, -40);
    }else{
      _chassis(-40, 40);
    }
  }*/
  //Stop
  drive(0,0);
  wait1Msec(100);
}

void _drivegyro_neg(int angle, int speed){
	while((D_gyro) > angle - 100){
    //...Continue turning
    drive(speed, -speed);
  }
  //Brief brake to eliminate some drift
  drive(-45, 45);
  wait1Msec(100);
  /*Second while loop to move more slowly toward the goal
  while((D_gyro) != angle){
    if((D_gyro) < angle){
      _chassis(-40, 40);
    }else{
      _chassis(40, -40);
    }
  }
  //Stop*/
  drive(0,0);
  wait1Msec(100);
}
